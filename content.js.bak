// Helper function to introduce a delay
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Fonction pour simuler la saisie de texte dans une div éditable
async function typeIn(element, text) {
    element.focus();
    // execCommand est une méthode plus fiable pour simuler une saisie utilisateur
    document.execCommand('insertText', false, text);
    element.dispatchEvent(new Event('input', { bubbles: true }));
}

// Fonction pour détecter si une chaîne est un numéro de téléphone
function isPhoneNumber(str) {
    // Un simple test : la chaîne est composée de chiffres, avec un '+' optionnel au début.
    return /^\+?[0-9\s]+$/.test(str);
}

/**
 * Convertit une Data URL (base64) en un objet File.
 * @param {string} dataurl La data URL à convertir.
 * @param {string} filename Le nom du fichier à créer.
 * @returns {File} L'objet File résultant.
 */
function dataURLtoFile(dataurl, filename) {
    let arr = dataurl.split(','),
        mime = arr[0].match(/:(.*?);/)[1],
        bstr = atob(arr[1]),
        n = bstr.length,
        u8arr = new Uint8Array(n);
    while (n--) { u8arr[n] = bstr.charCodeAt(n); }
    return new File([u8arr], filename, { type: mime });
}

/**
 * Attend qu'un élément correspondant au sélecteur apparaisse dans le DOM.
 * @param {string} selector Le sélecteur CSS de l'élément à attendre.
 * @param {number} timeout La durée maximale d'attente en millisecondes.
 * @returns {Promise<Element>} Une promesse qui se résout avec l'élément trouvé.
 */
function waitForElement(selector, timeout = 10000) {
    return new Promise((resolve, reject) => {
        const intervalTime = 200;
        let elapsedTime = 0;

        const interval = setInterval(() => {
            const element = document.querySelector(selector);
            if (element) {
                clearInterval(interval);
                resolve(element);
            } else if ((elapsedTime += intervalTime) >= timeout) {
                clearInterval(interval);
                reject(new Error(`Timeout: Element "${selector}" not found after ${timeout / 1000}s.`));
            }
        }, intervalTime);
    });
}

async function sendAttachmentBatch(files, caption) {
    if (!files || files.length === 0) return;

    const fileType = files[0].type;
    const isMedia = fileType.startsWith('image/') || fileType.startsWith('video/');
    const isAudio = fileType.startsWith('audio/');

    // Étape 2/9 : Trouver et cliquer sur le bouton "Joindre"
    const attachButtonIcon = await waitForElement("span[data-icon='clip'], span[data-icon='plus-rounded']", 10000).catch(() => {
        throw new Error("Étape 2/9 : Icône 'Joindre' (Trombone/Plus) introuvable.");
    });
    const attachButton = attachButtonIcon.closest('button');
    if (!attachButton) throw new Error("Étape 2/9 : Bouton 'Joindre' parent introuvable.");
    attachButton.click();

    // Étape 3/9 : Choisir le bon bouton (Média ou Document) en fonction du type de fichier
    let attachmentTypeIconSelector, attachmentTypeName;
    if (isMedia) {
        attachmentTypeIconSelector = "span[data-icon='media-filled-refreshed']";
        attachmentTypeName = 'Photos et vidéos';
    } else if (isAudio) {
        attachmentTypeIconSelector = "span[data-icon='ic-headphones-filled']";
        attachmentTypeName = 'Audio';
    } else {
        attachmentTypeIconSelector = "span[data-icon='document-filled-refreshed']";
        attachmentTypeName = 'Document';
    }

    const typeIcon = await waitForElement(attachmentTypeIconSelector, 5000).catch(() => {
        throw new Error(`Étape 3/9 : Icône '${attachmentTypeName}' introuvable dans le menu.`);
    });

    // Étape 4/9 : Trouver l'input de fichier caché dans le bouton correspondant
    const typeButton = typeIcon.closest("li[role='button']");
    if (!typeButton) throw new Error(`Étape 4/9 : Bouton '${attachmentTypeName}' parent introuvable.`);
    const fileInput = typeButton.querySelector("input[type='file']");
    if (!fileInput) throw new Error(`Étape 4/9 : Input de fichier pour '${attachmentTypeName}' introuvable.`);

    // Étape 5/9 & 6/9 : Assigner les fichiers à l'input et déclencher l'événement "change"
    const dataTransfer = new DataTransfer();
    const fileObjects = files.map(f => dataURLtoFile(f.dataUrl, f.name));
    fileObjects.forEach(file => dataTransfer.items.add(file));
    fileInput.files = dataTransfer.files;
    fileInput.dispatchEvent(new Event('change', { bubbles: true }));

    // Étape 7/9 : Attendre l'écran de prévisualisation (en cherchant l'icône d'envoi)
    const sendIcon = await waitForElement("span[data-icon='send'], span[data-icon='wds-ic-send-filled']", 15000).catch(() => {
        throw new Error("Étape 7/9 : Écran de prévisualisation non détecté (icône d'envoi introuvable).");
    });
    const sendButtonAttachment = sendIcon.closest('button, div[role="button"]');
    if (!sendButtonAttachment) throw new Error("Étape 7/9 : Bouton d'envoi final (parent) introuvable.");

    // Étape 8/9 : Ajouter la légende si elle existe
    if (caption) {
        const captionBoxSelector = 'div[aria-label*="légende"], div[aria-label*="caption"], div[data-testid="pluggable-input-body"]';
        const captionBox = await waitForElement(captionBoxSelector, 5000).catch(() => { throw new Error("Étape 8/9 : Zone de légende introuvable."); });
        await typeIn(captionBox, caption);
        await sleep(500);
    }
    // Étape 9/9 : Cliquer sur le bouton d'envoi final
    sendButtonAttachment.click();
    await sleep(2000); // Attendre que l'envoi se termine avant de continuer
}

/**
 * C'est la fonction principale qui envoie un message à un seul contact.
 * @param {string} contactName - Le nom du contact tel qu'il apparaît sur WhatsApp.
 * @param {string} message - Le message texte à envoyer.
 * @param {Array<object>} attachments - Le tableau de pièces jointes (optionnel).
 * @returns {Promise<{success: boolean, reason: string}>} Un objet indiquant le succès et la raison en cas d'échec.
 */
async function sendMessage(contactName, message, attachments) {
    // Sélecteurs pour les éléments de WhatsApp Web. Ils peuvent changer avec les mises à jour de WhatsApp.
    // Nous les rendons plus robustes en incluant plusieurs possibilités (anglais, français, attributs techniques).
    const SEARCH_BOX_SELECTOR = 'div[title="Search input box"]';
    const MESSAGE_BOX_SELECTOR =
        'div[title="Type a message"], div[aria-label="Entrez un message"], div[aria-label="Envoyer un message"], div[data-tab="10"][role="textbox"]';
    const SEND_BUTTON_SELECTOR =
        'button[aria-label="Send"], button[aria-label="Envoyer"], button[data-testid="send"]';
    const CLEAR_SEARCH_SELECTOR = 'button[aria-label="Clear search"]';

    try {
        // --- 1. OUVRIR LA DISCUSSION ---
        if (isPhoneNumber(contactName)) {
            const tempLink = document.createElement('a');
            const phoneNumber = contactName.replace(/[\s+]/g, '');
            tempLink.href = `https://web.whatsapp.com/send?phone=${phoneNumber}`;
            document.body.appendChild(tempLink);
            tempLink.click();
            document.body.removeChild(tempLink);
            await sleep(1500);
        } else {
            const searchBox = await waitForElement(SEARCH_BOX_SELECTOR);
            const clearButton = searchBox.closest('div').querySelector(CLEAR_SEARCH_SELECTOR);
            if (clearButton) { clearButton.click(); await sleep(500); }
            await typeIn(searchBox, contactName);
            await sleep(2000);
            const contactElement = await waitForElement(`span[title="${contactName}"]`);
            contactElement.closest('div[role="listitem"]').click();
            await sleep(1000);
        }

        // --- 2. ENVOYER LE CONTENU ---
        const mediaAttachments = attachments.filter(att => att.type.startsWith('image/') || att.type.startsWith('video/'));
        const audioAttachments = attachments.filter(att => att.type.startsWith('audio/'));
        const docAttachments = attachments.filter(att => !mediaAttachments.includes(att) && !audioAttachments.includes(att));
        let captionSent = false;

        if (mediaAttachments.length > 0) {
            await sendAttachmentBatch(mediaAttachments, message);
            captionSent = true;
        }

        if (audioAttachments.length > 0) {
            // Les messages vocaux sont envoyés sans légende pour éviter les doublons de message
            await sendAttachmentBatch(audioAttachments, null);
        }

        if (docAttachments.length > 0) {
            await sendAttachmentBatch(docAttachments, null); // Pas de légende pour les documents pour éviter les doublons
        }

        if (message && !captionSent) {
            const messageBox = await waitForElement(MESSAGE_BOX_SELECTOR, 15000);
            await typeIn(messageBox, message);
            await sleep(500);
            const sendButton = document.querySelector(SEND_BUTTON_SELECTOR);
            if (!sendButton) throw new Error("Le bouton d'envoi est introuvable.");
            sendButton.click();
        }

        await sleep(1000); // Attendre un peu après l'envoi
        return { success: true, reason: 'Envoyé' };
    } catch (error) {
        console.error(`Erreur lors de l'envoi à ${contactName}:`, error);
        return { success: false, reason: error.message };
    }
}

// Écouteur principal pour les messages provenant du popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === "sendBulkMessage") {
        (async () => {
            const { message, contacts, attachments } = request;
            const totalContacts = contacts.length;
            let successCount = 0;
            let errorDetails = [];

            for (let i = 0; i < totalContacts; i++) {
                const contact = contacts[i];
                const result = await sendMessage(contact, message, attachments);
                if (result.success) {
                    successCount++;
                } else {
                    errorDetails.push(`${contact}: ${result.reason}`);
                }

                // Envoyer une mise à jour de la progression au popup après chaque contact
                chrome.runtime.sendMessage({
                    action: "updateProgress",
                    processed: i + 1,
                    total: totalContacts,
                    currentContact: contact
                });

                // Délai aléatoire entre les messages pour éviter d'être détecté comme un bot
                await sleep(Math.random() * 2000 + 1000); 
            }

            let finalStatus = `Terminé. ${successCount} message(s) envoyé(s) avec succès.`;
            if (errorDetails.length > 0) {
                finalStatus += ` ${errorDetails.length} échec(s).`;
                console.error("Détails des erreurs:", errorDetails);
            }
            
            sendResponse({
                status: finalStatus,
                errors: errorDetails // On renvoie le tableau des erreurs
            });
        })();
        
        // Retourner true pour indiquer que la réponse sera envoyée de manière asynchrone
        return true; 
    }
});
